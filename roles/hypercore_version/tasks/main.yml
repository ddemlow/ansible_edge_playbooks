

  - name: Check if there is already an update in progress
    scale_computing.hypercore.version_update_status_info:
    register: update_status_before_update

  - name: Current update status
    ansible.builtin.debug:
      var: update_status_before_update


  - name: Get hypercore cluster info
    scale_computing.hypercore.cluster_info:
    register: cluster_info

  - name: Show cluster info
    ansible.builtin.debug:
      var: cluster_info

  - name: Get a list of updates
    scale_computing.hypercore.version_update_info:
    register: result      

  - name: Get node info
    scale_computing.hypercore.node_info:
    register: node_info

  - name: Show node info
    ansible.builtin.debug:
      var: node_info

  - name: Check if single-node system - fail if it is
    ansible.builtin.fail:
      msg: >-
        The play should be not be used with single node systems.
        This system has {{ node_info.records | length }} nodes.
    when: node_info.records | length == 1

  # ===================================================================

  - name: Update
    block:
      - name: Get available updates
        scale_computing.hypercore.version_update_info:
        register: available_updates

      - name: Show available updates
        ansible.builtin.debug:
          var: available_updates

      - name: Check if desired update is available - fail if not available
        ansible.builtin.fail:
          msg: >-
            Requested update {{ hypercore_desired_version }} is not
            in available_updates {{ available_updates.records | map(attribute='uuid') | list }}
        when: not hypercore_desired_version in (available_updates.records | map(attribute='uuid') | list)


  # - name: Report if out of version compliance (skipped if compliant - host execution will end)
  #   ansible.builtin.debug: 
  #     msg: update required on  {{inventory_hostname}} {{cluster_info.record[0].clusterName }} is {{cluster_info.record[0].icosVersion | trim }} while desired version is {{hypercore_desired_version}} 
  #   when: ( cluster_info.record[0].icosVersion  | trim ) != hypercore_desired_version
  #   ignore_errors: yes
  #   tags:
  #     - checkversion

  # - name: Check version compliance - end host execution if compliant - else continue checking
  #   ansible.builtin.meta: end_host
  #   when: ( cluster_info.record[0].icosVersion  | trim ) == hypercore_desired_version

  - name: apply desired version to cluster or SNS  #will submit update request and continue without monitoring
    scale_computing.hypercore.version_update:
      icos_version: "{{ hypercore_desired_version }}"
    register: update_desired

  # - include_tasks: check_hc_update.yml      

  # - name: Check update progress to "{{ hypercore_desired_version }}" - will report FAILED-RETRYING until update COMPLETE or TERMINATED
  #   scale_computing.hypercore.version_update_status_info:
  #   register: update_status
  #   until: ( update_status.record.update_status == "COMPLETE" | default(omit) or update_status.record.update_status == "TERMINATING" | default(omit)) and update_status.record.to_version == hypercore_desired_version | default(omit) #maching to_version ensures new update attempt has started
  #   retries: 1000
  #   delay: 5
  #   ignore_unreachable: true

#try using role to check updates

  - name: use update check from sns update role #has inner and outer retry loops
    ansible.builtin.import_role:
      name: scale_computing.hypercore.version_update_single_node
      tasks_from: update_status_check.yml



  # - name: Check update progress to "{{ hypercore_desired_version }}" - will report FAILED-RETRYING until update COMPLETE or TERMINATED
  #   scale_computing.hypercore.version_update_status_info:
  #   register: update_status
  #   until: ( update_status.record.update_status == "COMPLETE" | default(omit) or update_status.record.update_status == "TERMINATING" | default(omit)) and update_status.record.to_version == hypercore_desired_version  #maching to_version ensures new update attempt has started
  #   retries: 100
  #   delay: 30
  #   ignore_unreachable: true   

  # - name: Check IF HyperCore version meets desired version late in update 
  #   register: cluster_info
  #   ignore_errors: yes
  #   ignore_unreachable: yes

  # - name: Show VMs to restart
  #   ansible.builtin.debug:
  #    msg: "{{shutdown_vms}}"
    
  # - name: Restart previously running VM's on SNS # if this retry works - maybe just do this - would work on either failure or success? 
  #   scale_computing.hypercore.vm_params:
  #     vm_name: "{{ item.vm_name }}"
  #     power_state: start
  #   loop: "{{ shutdown_vms }}"
  #   when: ( node_info.record | length ) == 1
  #   register: restart
  #   until: item.power_state == "started"
  #   retries: 10
  #   delay: 60
  #   ignore_errors: true
  #   ignore_unreachable: true
  #   timeout: 120

  # - name: Report if out of version compliance (skipped if compliant - host execution will end)
  #   ansible.builtin.fail:  # not sure fail here is best option - but it's ignored
  #     msg: update FAILED on  {{ inventory_hostname }} {{ cluster_info.record[0].clusterName }} is {{ cluster_info.record[0].icosVersion | trim }} while desired version is {{ hypercore_desired_version }} 
  #   when: ( cluster_info.record[0].icosVersion  | trim ) != hypercore_desired_version
  #   ignore_errors: false
  #   tags:
  #     - checkversion
